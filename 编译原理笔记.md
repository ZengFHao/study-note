# 编译原理复习大纲

## 第一章 引言

- 语言之间的翻译模式：根据输入语言和输出语言的层次进行划分

  - 编译：将高级语言输出为汇编或者机器语言
  - 汇编：汇编语言翻译成机器语言
  - 转换（预处理）：定义的define等
  - 交叉汇编：将A2平台的汇编语言运行在A1平台上，两个平台汇编指令不同
  - 反汇编
  - 反编译

- 语言之间的翻译形态

  - 编译型：先翻译后执行
  - 解释型：边翻译边执行

- 编译器的基本组成

  - 编译器对两类语言的编译
    - 声明型语句：填写符号表，生成相对应的环境
      - 如变量分配空间等
    - 操作性语句：生成中间代码
      - 三地址码
      - 注释树

  ![image-20230213144113827](image\image-20230213144113827.png)

- 各阶段的输入输出

  - 词法分析
    - 输入：字符流（源程序），唯一和与源程序打交道的阶段
    - 输出：记号流

  - 语法分析
    - 输入：记号流
    - 输出：语法树/分析树

  - 语义分析
    - 输入：语法树/分析树
    - 输出：语法树/分析树（只是在树上又加了一些注释，所以又称注释语法树）

- ==编译器以中间代码生成为界限将其分为前端和后端==



## 词法分析

### 词法规则——立法

- **模式，记号，单词**
  - 模式：产生/识别单词的规则
  - 记号：按照某一模式识别出的元素
  - 单词：被识别出的元素的值
- **词法分析器的输出**
  - 输入是字符流，输出是记号流
  - 记号=种类+属性
- **词法分析器的工作模式**
  - **单独一遍扫描**：词法分析将源程序完全扫描一遍后产生记号流，词法分析完成之后才进行语法分析，严格的串行
  - **词法分析作为语法分析的子程序**：语法分析为主导，在语法分析的过程中需要用的时候，词法分析开始工作将识别出的记号返回给语法分析，是交替串行
  - **词法分析和语法分析并行工作**：词法分析不断写入记号，语法分析不断读出记号
- **词法分析器的作用**
  - 滤掉源程序中的无用成分，如空格，注释，回车
  - 处理与具体平台有关的输入，如文件结束符的不同表示
  - 识别记号，并将其交给语法分析器，根据模式识别记号
- **模式的形式化描述**
  - 语言L是有限字母表Σ上的长度有限的字符串集合，==两个有限！！==
    - 会前缀，后缀，真前缀，真后缀，子串，子序列，字符串的并，交，连接，差，闭包运算，见教材P19 
  - **正规式和正规集**
    - 正规式的定义， 见教材P20
    - 可用正规式描述的语言称为正规语言或正规集
    - 正规式的优先级和结合性
      - 都是左结合
      - 优先级闭包>连接>或
    - 若正规式P，Q表示同一个正规集则P,Q等价，也可以通过代数性质推导
  - **正规式的简化表示**
    - 正闭包：在正规式的定义中是不包含正闭包的，但在简化表示中引入了正闭包，且与星闭包有相同的结合性及优先级
    - 可缺省：r?=r|ε
    - 字符组：
      - 枚举，如[abc]等价于a|b|c
      - 分段，如[0-9a-z]
    - 非字符组：引入了非的概念

### 自动机——执法

- **记号的识别——FA**
  
  - **不确定的有限自动机和确定的优先自动机——NFA ，DFA**
    - 定义：(D|N)FA=(S, Σ ,move，S0， F)
      - S：有限个状态的集合
      - Σ：有限个输入的集合
      - move：状态转移函数
      - S0：初态==（唯一）==
      - F：终态集合（可多个）
    - 表示：
      - 定义：也就是写出上述五个要素的值
      - 状态转化图：初态的表示、终态的表示
        - 初态：带箭头的表示
        - 终态：两个圈或者加粗表示
      - 状态转移矩阵：初态放在第一行，终态在矩阵外单独表示
        - 列表示状态
        - 行表示输入序列
        - DFA转移一定是一个特定的状态，所以在表项中直接写出下一状态，但NFA由于下一状态有几个是不确定的，所以表项中用”{}“集合的形式来表示，哪怕下一状态只有一个
  - **识别记号的基本方法：**
    - 从左到右扫描输入序列，边扫描边进行状态转移，直到到达某个终态，或者无法到达终态
      - 可接受序列：能够正确到达终态
      - 不可接受序列：尝试了所有可能之后仍然无法到达终态
  - **NFA VS DFA的区别**
    - 某个状态下，对同一个字符可能有多个下一状态
    - 可能存在ε状态转移
  - **用NFA识别输入序列的弱点**：需要大量的尝试+回溯
  - **模拟DFA算法2.1**，见P26
    - 用DFA识别记号，只尝试不进行回溯
  
- **从正规式到词法分析器**

  正规式=> NFA => DFA => 最小DFA => 分析器 

  - **Thompson算法**：见P27
    
    - 分解正规式：按运算的逆序，自上而下借助语法树递归分解
    - 构造NFA: 按运算的正序，自下而上后序遍历树递归构造
    
  - **从NFA构造DFA (子集法)**： 见P32 例2.15
    
    - 关键在于理解ε—闭包 与smove（S， a）的计算
    
    - 具体步骤
    
      - DFA的初态=$ε-闭包({S_0})$记为A
    
      - 对A将所有输入进行转移形成集合B,C.....
    
      - 再对B，C.....对所有输入进行转移，直到不会出现新的集合为止
      
        $T^‘=\epsilon -闭包(smove(T,a))$
    
  - **DFA的最小化：见P34**
  
    - 计算一个状态数最少的，且是等价的DFA
    - 步骤
      - 初始划分$\pi$：状态组，非状态组
      - 反复分裂每个状态组（借用状态转移矩阵）
        - 同一状态组内的任意两状态是不可区分的
        - 不同状态组内的两个状态是可区分的
      - 选代表，改转移
      - 删除死状态，不可到达状态（一般就是孤点）

例如：

![image-20230217152144782](image\image-20230217152144782.png)

首先写出所有的状态集合，因为终态和非终态肯定是不一样的，所以它们可以先分开：

$$
\{ABCD,\ E\}
$$

接下来就看，**所有在一块的到底能不能拆开**。那么也就是尽可能去把ABCD拆开。此时，ABCD其实是一个整体，所以我们要把它们同等看待。因为ABC经过b之后都会到达这个整体，而D经过b之后会到达E，所以显然D和ABC是有区别的，应该拆开：

$$
\{ABC,\ D,\ E\}
$$

接下来就拆ABC这个整体。因为AC经过b都会到这个整体；而B经过b之后会到D，所以B也应该拆开：

$$
\{AC,\ B,\ D,\ E\}
$$

A和C经过a都会到B，经过b都会到自己这个整体，所以没法再拆了。那么最终自动机重画出来是这样的：

![image-20230217152158076](image\image-20230217152158076.png)



## 语法分析

### 语法规则——立法

- 输入是记号流，分析结果是句子（用树来表示）
  - 不是句子的句型只能用分析树，非叶子结点都是非终结符
  - 语法树上的叶子结点都是终结符
- **词法分析 VS 语法分析**
  - 词法分析：元素是字母，组成字符串，记号的集合，是线性结构
  - 语法分析：元素是记号，组成句子，句子的集合，树结构
- **语法分析器的作用**
  - 根据词法分析器提供的记号流，为正确的输入构造分析树（或语法树）
  - 检查输入中的语法错误（可能还包含词法错误），并调用出错处理器进行适当处理

![image-20230217164103918](image\image-20230217164103918.png)

- **源程序中可能出现的错误**
  
  - **语法错误（可能包含词法错误）**
    - 词法错误：非法字符，拼写错关键字、标识符等
    - 语法错误：语法结构错误，如少分号，{}不配对等
  - **语义错误（静态语义错误和动态语义错误）**
    - 静态语义错误：类型不一致，参数不匹配，除0操作等
    - 动态语义错误：死循环，除一个变量但是变量可为0等
  
- **文法的分类**

  - 0型、1型、2型、3型

  - 定义格式都是G=(N, T, P, S)

    - N：非终结符的有限集合
    - T：终结符的有限集合，且$N\cap T= \Phi$ 
    - P：产生式的有限集合
    - S：文法的开始符号（都是非终结符）

  - 3型文法也就是正规文法，描述正规集

    ![image-20230217153119624](image\image-20230217153119624.png)

  - 2型文法也就是上下文无关文法，描述上下文无关语言

![image-20230217153145672](image\image-20230217153145672.png)

### 上下文无关文法

- CFG是一个四元组G=(N , T , P , S )，其中N , T , S的定义都和上述文法的定义相同，所以只对P进行补充

  - P：形如$A \rightarrow \alpha$，其中

    - $A \in N$ (左部)
    - $\alpha \in (N \cup T)^* $ （右部）
    - 当$\alpha = \epsilon $，称为空表达式，可记为$A\rightarrow$

    > N可以出现在产生式左右两边
    >
    > T觉不能出现在产生式的左边！！！！！！

- **CFG产生语言的基本方法——推导**
  
  - 用产生式的右部替换句型中的非终结符
  
  - **推导的基本概念**：
  
    - 直接推导
      - $=>:$ 直接推导
      - $=>^*:$ 零步或多步推导
      - $=>^+:$至少一步推导
    - 最左推导，最右推导
      - 从文法的开始符号开始，每次变换都替换最左边（右边）的非终结符，推导至句子前的所有左推导（右推导）
    - 句子和句型
      - 句型：通过开始符号经过任意次推导而来的序列
      - 句子：如果一个句型仅由终结符组成，则称句型X为文法的一个句子
      - 句子也就是没有非终结符的句型
  
  - **分析树和语法树**
  
    - 结点上标记的文法符号是不同的
  
      - 语法树的所有结点都是终结符
  
        ![image-20230218114103554](image\image-20230218114103554.png)
  
      - 分析树只有叶子结点是终结符
  
        ![image-20230218114122437](image\image-20230218114122437.png)
  
      - 分析树记录了分析过程
  
        - 如果自上而下构造，则构造过程既是推导又是自上而下的语法分析过程
        - 如果自下而上构造，则构造过程是自下而上的语法分析过程
  
  - **文法的分析的二义性**
  
    - 文法中缺少对文法符号优先级和结合性的规定，导致一个句子可能有多于一棵的分析树
  
  - **二义性的消除**（只需要知道有这两种方法，不需要具体实现）
  
    - 改写二义文法为非二义文法
    - 对文法符号施加优先级和结合性的限制，使得分析的每一步都有唯一选择
  
  - 为什么用正规式而不是上下文无关文法来描述词法
  
    - 词法规则简单，用正规式描述就够了
  
    - 正规式的表示比CFG更为简单直观
  
    - 有限自动机的构建比下推自动机简单，且效率更高
  
    - 区分词法和语法，使编译器前端的模块划分更方便
  
      > 正规式无法表示递归含义
  
  
  ![image-20230218114813689](image\image-20230218114813689.png)



- **自上而下分析**

  - 基本思想：从文法的开始符号开始，进行最左推导，从上到下构造分析树

  - 对文法要求：无左因子，左递归，所有文法都要求无二义性

    - 左递归：产生式的右部以产生式的左部打头

      如：$A \rightarrow A \alpha|\beta$

    - 左因子：一个产生式的多个候选项，有相同因子打头

      如$A\rightarrow \alpha \beta_1 | \alpha \beta_2$

  - **消除直接左递归的方法**

    - 寻找一个和文法等价，但是没有左递归的文法,==通常以直接右递归来代替直接左递归==

    ![image-20230218115246779](image\image-20230218115246779.png)

  - **提取左因子的方法**：

    - 和算数表达式提起公因子的方法是一样的
    - 但是同一个候选项内部不能有圆括号和竖线，不允许出现，则通过引用一个新的非终结符来替换即可

    ![image-20230218120043033](image\image-20230218120043033.png)



- **递归下降分析**

  - 每个非终结符（A），构造一个子程序（A），有几个候选项就形成几个分支

  - 右部：展开为子程序的过程体，其中

    - 非终结符B：展开为B的调用

    - 终结符t：匹配该终结符，match（t）

- **预测分析（表驱动型）**

  - 工作方式和过程

    - PDA：下推自动机
    - 格局
    - 改变格局的动作

  - **分析表的结构、驱动器**

    - **分析表**

      - FIRST（X）的计算，==从文法自下而上计算==

        - 终结符：终结符只能推导其自身，所以终结符的FIRST集合只有其本身

          $FIRST(X)={X} $      //X为终结符

        - 若X是非终结符且有$X\rightarrow \epsilon$，则把$\epsilon$加入到FIRST(X)

        - 非终结符：把每个候选项的FIRST求出之后，再进行并集运算4

          $FIRST(N)= \cup FIRST(候选项\alpha)$      //N为非终结符

          也就是说如有文法$A\rightarrow Y_1,Y_2,Y3....$，则看$Y_1$的FIRST，如果其中有$\epsilon$，则再加上$Y_2$的FIRST，如果还有则看$Y_3$，一直重复下去，如果全部都有$\epsilon$，则把$\epsilon$也加入到FIRST(X)

        - FIRST($\alpha$)的计算  ==重难点==
      
      - FOLLOW的计算，==从文法自上而下计算==
      
        - FOLLOW(N)的计算
      
        - 要点
          - 如果N是开始符号，那么FOLLOW一定有一个#号表示输入结束
          - 对于其他的非终结符就要看N出现在了那些产生式的右部，也就是下一个的FIRST，或者空
          
        - 步骤：
      
          - 如果是开始符号的FOLLOW，则先把“#”加入
      
          - 若产生式为$A\rightarrow \alpha B \beta$，则除了$\epsilon$以外的FIRST($\beta$)，加入到FOLLOW(B)
      
          - 若有产生式$A\rightarrow \alpha B \beta 或A\rightarrow \alpha B$，且$\epsilon \in FIRST(\beta) $，则FOLLOW(A)全体加入到FOLLOW(B)
      
            ![image-20230223160748813](image\image-20230223160748813.png)
      
      
        > FIRST的参数是任意的，可以使终结符，也可以是非终结符，无论什么参数一定有一个打头的东西存在
        >
        > FOLLOW集合的参数就一定是非终结符，因为你要有FOLLOW证明你一定能进行推导将其替换，那么只有非终结符才能进行推导，终结符已经结束推到了当然不会有FOLLOW，==FOLLOW集合中都不没有$\epsilon$==
      
      - 分析表的构造：也就是将FIRST填入表中的过程
      
        - 将候选项分别填入FIRST(X)对应的表格之中
        - 将$\epsilon$分别填入带有$\epsilon$的文法X的FOLLOW(X)对应表格
      
        ![image-20230223162200351](image\image-20230223162200351.png)

  - **LL(1)文法及其判别**

    - LL(1)文法：文法中的每个非终结符编写一个函数(或子程序),每个函数(或子程序)的功能是识别由该非终结符所表示的语法成分

    - 判别：预测分析表中没有多重定义的条目，==要么什么都不填，要么只填了一个==

      > 也就是说二义/含左递归/含左因子的，都不是LL（1）文法

- **自下而上分析**

  - 基本思想：最左规约（最右推导的逆过程）,以句子为根据从叶子结点构造分析树

  - 基本概念:短语、直接短语、句柄、最左规约

    ​	短语>直接短语>句柄

    ​	若存在$S=>^*\alpha A \sigma,A=>^* \beta$

    - 短语：$\beta 成为句型\alpha \beta\sigma 相对于A的短语$（只要是一个非终结符可以变出来的）
    - 直接短语：$若有A\rightarrow\beta,则称\beta是句型\alpha \beta\sigma相对于产生式A\rightarrow\beta的直接短语$
    - 句柄：一个句型的最左直接短语称为句柄

    >
    >
    >直观上，句型是一个完整结构，短语是句型中的某些部分（针对于非终结符），S是一个句型而不是一个短语（树根不是短语）

    > ==在分析树上的表现形式是很重要的==

    - 树上的表现形式

      - 短语：以非终结符为根子树中所有从左到右的叶子（每一个非终结符）
      - 直接短语：只有父子关系树中所有从左到右排列的叶子（最底层的每个以非终结符为根的子树）
      - 句柄：最左边父子关系树中所有从左到右排列的叶子（最底层最左边的以非终结符为根的子树，句柄是唯一的）

      ![image-20230219173335533](image\image-20230219173335533.png)

  - **基本方法**

    ​	**剪句柄**

    - 起点是一个句子，将其逐步收缩，和推导从一个开始符号逐步展开成一个句子是正好相反的
    - 根据文法将句子的分析树画出，当有左递归的时候就一个一个试看哪种情况能展开成对应的句子
    - 在根据句柄的概念每次消除一个句柄逐步把树收缩

    ![image-20230219174351553](image\image-20230219174351553.png)

    

    **用移进——规约方法实现剪句柄**

    - 相关概念

      - 格局（#栈中内容，当前剩余输入#，改变格局的动作）
      - 改变格局的动作
        - 移进：输入序列中的终结符进栈（匹配终结符）
        - 规约：将栈顶句柄替换为对应非终结符（最左规约）
        - 接受：宣告分析成功
        - 报错：发现语法错误，调用错误恢复

    - 实现过程

      ![image-20230219175123698](image\image-20230219175123698.png)

      

      

  - **关键问题**

    - 在剪句柄之前要求句子要有分析树，但这个要求对于语法分析来说是不现实的，因为语法分析在没有进行之前输入对不对都不知道，更不用说分析树了
    - 如何确定栈顶已经形成句柄：观察文法的产生式，句柄一定会首先形成在栈顶
    - 当句柄形成时，如何判定采用哪种产生式进行规约
      - 移进规约
      - LR方法：移进——规约分析表+驱动器
      - SLR(1)方法

- **识别活前缀的**DFA

- - **活前缀**：移进—规约分析栈中右句型的前缀

    - 前提

      - 右句型的前缀
      - 已经在分析栈中

      即：活前缀+若干剩余输入（不在栈中）=>右句型（最右推导产生的句型）

      ![image-20230220114149458](image\image-20230220114149458.png)

  - **LR(0)项目与NFA**

    - 一个LR(0)项目是NFA的一个状态，即一个"."，在其之前的状态都已经走过

    - 一个产生式是识别一组活前缀的NFA

      ![image-20230220114915690](image\image-20230220114915690.png)

    - 所有产生式就构成了识别所有活前缀的NFA

    > 可移进项目 ： $ A \rightarrow \alpha . \beta$  在右端还有文法符号
    >
    > 可规约项目 ：$A \rightarrow \delta .$ 后面什么都没了

  - ==拓广文法==

    - 准备工作：引入新的开始符号

      G' = G$\cup$  {$S' \rightarrow S$}		(S'其实也就是S）

      ![image-20230220115625966](image\image-20230220115625966.png)

      - 原因：每个产生式可能有多个候选项，那么每个候选项都会对应各自的开始符号，以上图为例，整个分析的初态到底是（1）的还是（2）的开始符号？所以引入一个新的开始符号E'来表示这整个文法的开始符号就不会有歧义了

    - 状态的表示

      - 初态：S'$\rightarrow$.S（与之前相同用一个没有出处的箭头表示）
      - 终态：S'$\rightarrow$ S.（与之前相同用加粗的框表示）

      ![image-20230220121702995](image\image-20230220121702995.png)

  - ==子集法构造DFA(goto(I,X) , closure(I))==

    - 两个过程

      - closure(I)：从项目集I不经过任何文法符号到达的项目全体，==类似$\epsilon—闭包$==
      - goto(I,x)：所有从I经文法符号x能直接到达的项目全体，==类型smove==

    - 求闭包

      - I中的所有项目都属于closure(I)，自己肯定属于自己

      - 若A$\rightarrow \alpha.B\beta$属于closure(I)，则所有形如B$\rightarrow .\gamma$的项目都属于closure(I)，就相当于$\epsilon$一样可以跳到B

        以上图为例，也就是说0状态可以之计跳转到状态2和状态6，通俗来说就是"."在非终结符前面就直接跳到该终结符的初态

        ![image-20230220122238341](image\image-20230220122238341.png)

    - 求goto：对所有属于项目集I、且形如[$A\rightarrow\alpha.X\beta$]的项目，则goto(I,X)是所有形如[$A\rightarrow\alpha.X\beta$]的项目

    - 用第二章的思路

      ![image-20230220123019281](image\image-20230220123019281.png)

      ![image-20230220123402196](image\image-20230220123402196.png)

      >
      >
      >和第二章是一样的，先求goto，然后再求closure，也就相当于先求状态转移再求$\epsilon$闭包
      >
      >当某个集合没有出去的边时，并不是说输入就一定是非法的，往往是某个子结构的终态，并不是闷着头往前走，这种时候就要==即“.”在最后的时候进行规约然后回退==，用下图来替换上图会更加方便

      ![image-20230220125341042](image\image-20230220125341042.png)

      >初态：I0
      >
      >终态：I1
      >
      >也就是逐步把"."往后移的过程，以及怎么移

      


  ![image-20230218151300489](image\image-20230218151300489.png)

- **DFA识别输入序列**

  - **移进/规约冲突**：到底是该移进，还是规约呢

    ![image-20230218154410486](image\image-20230218154410486.png)

  - **规约/规约冲突**

  ![image-20230218154420306](image\image-20230218154420306.png)

  ![image-20230220130549207](image\image-20230220130549207.png)

  

  - **解决冲突的方法——SLR(1)**

    简单向前看一个终结符

    - 移进规约

      $FIRST(\beta_2) \cap FOLLOW(B)=\Phi ?$ 

      - 如果交集为空则可以解决

    - 规约规约

      $FOLLOW(B) \cap FOLLOW(E) = \Phi ?$

      - 如果交集为空则可以解决

    - 当有复杂情况时

      三个式子两两结合看三个交集是否为空

- **移进—规约分析表**

  - 动作表+转移表

    ![image-20230219185100288](image\image-20230219185100288.png)

    - 每一行就是一个状态
    - 每一列就是一个动作：分为终结符和非终结符

  - **SLR(1)分析表的构造**

    - 有多少状态则有多少行，第一行则为初始状态，每一列就是一个终结符或者非终结符，==但是别忘了"#"==
    - 先记录状态转移关系：
      - 终结符：移进状态x，记为sx
      - 非终结符：只需要记录状态即可
    - 再记录回退的状态
      - 终态遇到“#”，则回退acc表示接受
      - 根据FOLLOW集合，集合中有的对应位置填入rx

- **LR文法和LR文法分析**

  - 格局

    - 开始格局：（#0，w#，移进）

    - 结束格局：（#0S， #，接受）

    - 出错格局：（#$\sigma$，w'#，报错）

  - 改变格局的动作

    - 移进：action[s,a]=Si
    - 用第j个产生式的左部替换栈中句柄：action[s,a]=r j
    - 接受：action[s,a]=acc
    - 报错：action[s,a]=blank
    - s状态下遇到A转移到状态s‘：goto[s，A]=s’

    ![image-20230220113102707](image\image-20230220113102707.png)

    > 
    >
    > 但第五行操作认为是PPT有问题应该动作是S6，但由于操作都是S5所以对结果没产生影响

  - LR(0):画出DFA，看DFA是否有冲突，如果没冲突则是LR(0)文法，有冲突则不是LR(0)

  - SLR(1):画出DFA，看DFA是否有冲突，当有冲突的时候通过分析都是可以解决的则是SLR(1)文法，有冲突的无法解决则说明不是SLR(1)文法

    

    

## 静态语义分析

- 作用：
  - 检查是否结构正确的句子所表示的意思也合法
  - 执行规定的语义动作
    - 表达式求值
    - 符号表填写
    - 中间代码生成

- 语法制导翻译

  - 语法制导翻译定义：以语法分析为基础，伴随语法分析的各个步骤，执行相应的语义动作

    - 将文法符号所代表的语言结构的意思，用附着该文法的属性表示

      比如文法中id的值是多少？问法中的非终结符T存在哪？

  - 文法规定

    - 本章的文法一般为二义文法，因为二义文法造出来的树一般都比较矮好分析，默认解决二义的方法是规定常规意义下的优先级和结合性，比如比人“+”是左结合的等等

  - 语义规则：配给一个个产生式来完成属性计算的程序，以$A \rightarrow \alpha$为例，其中$\alpha$是由一系列文法符号X1X2...Xn组成，其中包含了终止符合非终止符，也可以说就是属性之间的计算

  - 属性： 

    - 定义：对于上述产生式的语法规则，也就是一些抽象函数能够算出来一些值，比如b=f(c1,c2,...,ck)

      - 综合属性：b是A的属性，c1，c2,...，ck是$\alpha$中文法符号的属性，或者A的其他属性（兄弟产生式的属性）（父结构的属性需要综合子结构的属性） 

        eg：$E\rightarrow E1+E2 \ E.val=E1.val+E2.val$  

      - 继承属性：b是$\alpha$中某些文法符号Xi的属性，c1，c2，...，ck是属性或者$\alpha$中其他文法符号的属性

      - 依赖关系：b就依赖于c1,c2,...,ck（有了这一堆才能算出最终的b）

        >
        >
        >继承属性是从前辈或者兄弟属性计算得到，综合属性从子孙和自己的其他属性计算得到，本章节都是基于自下而上的分析，所以都默认是综合属性

    - E.val：值

    - E.type：类型

    - E.code：代码序列

    - E.place：存储空间

  - 语义规则的两种表现形式

    - 语法制导定义：用抽象的属性和运算表示的语义规则（设计）（算法）
    - 翻译方案：用具体的属性和运算表示语义规则（实现）（程序） 

- 中间代码

  - 为什么生成中间代码

    - 便于编译器的开发移植和代码优化

  - 中间代码的特征
    - 和机器指令接近
    - 便于用语法制导翻译产生

  - 最常用的中间代码表现形式
    - 后缀式：操作数在前，操作符在后，无需使用括号限制运算的优先性和结合性

      eg:

      ​	3+5+8  =>3 5 + 8 +

      ​	3+(5+8)=>3 5 8 + +

      ​	3+5*2/7=>3 5 2 * 7 / +

      ​	(3+5)*(2/7)=>3 5 + 2 7 / *

      ![image-20230221142257362](image\image-20230221142257362.png)

    - 三地址码： 由不超过三个地址组成的运算

      eg：

      ​	x:=a+b*c

      ​	T1:=b*c

      ​	T2:=a+T1

      ​	x:=T2

      - 实现方式：三元式与四元式

        三元式：

        eg: x:=a+b*c

        (1)(*,b,c) 

        (2)(+,a,(1))

        (3)(:=,x,(2))

        - 标识符a，b，c，x分别表示他们的存储位置
        - 序号(1)(2)(3)，分别是他们在三元式表中的位置
        - 序号的双重含义：既代表此三元式，又代表三元式存放的结果
        - 存放方式：数组结构，三元式在数组中的位置由下标决定
        - 缺点：给代码优化带来困难

        ![image-20230221152748793](image\image-20230221152748793.png)

      **四元式**：对三元式的改进，将表示计算结果的三元式序号用一个显示的变量表示

      eg: 

      ​	x:=a+b*c

      ​	(1)(*,b,c,t1)

      ​	(2)(+,a,t1,t2)

      ​	(3)(:=,x,t2,t3)	

      ![image-20230221153922448](image\image-20230221153922448.png)

      ![image-20230221154159562](image\image-20230221154159562.png)

    - 注释语法树  ：以语法树为基础，加入了语义信息

    ![image-20230221154857920](image\image-20230221154857920.png)

    ![image-20230221155129499](image\image-20230221155129499.png)

    > 树的后续遍历也就是原表达式的后缀式
    >
    > 内部结点上面如是三元式则用序号的方式给出注释，如果是四元式则用变量的形式给出注释

  - 树：最基本的表现形式

- 符号表

  - 条目：名字+属性

  - 存储格式
    - 直接存储：直接将构成名字的字符串存放在符号表条目中的方式
    - 间接存储：将构成名字的字符串统一存放在一个大的连续空间中，字符串与字符串之间用特殊分隔符隔开（“#”）
    
    >
    >
    >间接存储适用于长度变化很大，并且长度不确定的字符串
    
  - 作用域规则

    - 静态作用域原则：编译时就能确定名字的作用域
    - 最近嵌套原则：名字的声明在离其最近的内层起作用

  - 组织形式

- 声明语句的翻译

  - 变量声明：为变量分配存储空间
    - 一个变量的声明=类型的定义和变量的声明
    - 类型定义：为编译器提供存储空间大小的信息
    - 符号表信息的填写
    - 分配存储空间
  - 过程声明
    - 过程=过程头+过程体
    - 左值右值
      - 形式上：出现在赋值号左右两边的变量
      - 实质上：左值必须有存储空间，而右值可以只是单纯的数值
      - 左值相当于容器，右值相当于内容
    - 参数传递
      - 值调用：传入的普通参数，过程内对参数的修改不会影响实参
      - 引用调用：过程内的修改影响实参，类似于&
      - 复写-恢复调用：过程内对参数的修改不影响实参，返回时将形参内容赋给实参，类似于return
      - 换名调用：类似于宏替换，define了一个宏
    - 名字和作用域信息的保存：符号树

- 可执行语句的翻译

  - 类型转化
  - 数组的引用翻译：映射方式 
  - 布尔表达式：拉链/回填技术
    - 数值表示的直接计算，逻辑表示的短路运算
    - 真假出口：表达式为真（假）时的转向
    - 真假出口链：链接转向真（假）出口的三地址码
    - 拉链回填：当goto不知道去哪时登记到链表上，知道出口时回填
  - 控制语句的翻译





### 练习题中的小tips

- 静态语义错误：比如说算数除0操作，是在编译就能直接判断出的，但具体的步骤是在语义分析

- 词法分析/语法分析混淆点：

  - 以int 123x为例

    虽然在变量的定义时，这是一个错误的标识符，按理说是一个词法错误，应当在词法分析的时候检测出，但词法分析只负责识别单词，会将其识别为123，x两个记号。在将记号传个语法分析的时候，发现本来是一个变量的记号居然是123，则把这样统称为是一个语法错误

- 当出现对标识符的引用时，编译器一定要查询符号表，看看其中存放的该标识符信息

- 当计算过程中出现自动类型转化是是在语义分析阶段

- 语法分析/语义分析混淆点

  - 以a[10];b=2;a=b为例

    语法分析只会去扫描：哦~知道这是一个记号给另一个记号赋值，只是知道这样的一个结构，但是这个结构下对于的逻辑对不对就不是语法分析关心的事情了，语义分析的时候才是具体看句子的逻辑是否正确。

    同理给一个const x赋值也应当是一个语义错误

- 如果要画NFA的状态转移矩阵，则$\epsilon$要单独作为一个属性成列

![image-20230227144749201](image\image-20230227144749201.png)

- 句柄和直接短语：最下层的左子树，不一定只有一个叶子，也不可能为空

- 在移进规约冲突中，不只是非终结符之间需要比较，终结符也可以发生移进规约冲突，并且终结符的FIRST集合就是其本身

  
