# 数据库考试复习大纲

## 摘要

tips：高老师明确指出，数据库考试题型几乎是不变的，每个大题考的知识点固定，变化的是选择题，mooc上的练习题全是以前的原题！！！！

from：高海昌老师复习课

author:  zfh

## 第一章

- 什么是数据
  - 用于描述人，对象，事件的原始事实

- 什么是数据库
  - 相关数据的集合

- 什么是DBMS
  - 数据管理系统，是管理数据库的软件

- 抽象出来的三个层次
  - 物理层：面向磁盘的一个个扇区
  - 逻辑层：面向表，常常面对逻辑层操作，也就是存的是一张张表
  - 视图层：面向一张张视图
- 外模式，模式，内模式对应上述三层
  - 外模式——视图层
  - 模式——逻辑层
  - 内模式——物理层

- 实例和模式之间的概念
  - 实例：特定时刻存储在数据库中的信息的集合
  - 数据库的总体设计

- 数据库领域四个获得图灵奖的人名，可能会出选择题问下列谁未获得过
  - 查尔斯·巴赫曼
  - 埃德加·弗兰克·科德
  - 詹姆斯·古瑞
  - 迈克尔·斯通布雷克


## 第二章 关系模式

- 属性的类型，可能会考将一张图中未标完整的属性补充完整
  - 主码，外码，超码，候选码的概念要清晰
    - 超码：能够通过其来区分关系中的不同元组
    - 候选码：超码中最小的，是超码的一个子集
    - 主码：从候选码中挑选出来用于区分不同元组的属性集，剩余的称为替换码
    - 外码：匹配到另一关系中的候选码
- ==关系代数语言 ， 一定会考一个大题！！！！==
  - 写出关系表达式
  - 写出SQL语言
- 六大操作必须掌握：把老师给的例子都能写出来考试就没问题
  - 选择：σ
  - 投影：π
  - 并：∪
  - 集合差：－
  - 笛卡尔积：×
  - 重命名：ρ
- 练习题比较重要



## 第三章 SQL

- 了解各种类型的变量，char，varchar等
- 创建表
- 创建约束
  - 主码约束
  - 外码约束
  - 完整性约束
- 增删改查，更新，from-where等操作（但不需要太深入，三五行的那种，看懂课堂用例即可）
- 字符串操作，排序，分组
- 集合的并，交，差
- 五大内建函数
  - avg
  - min
  - max
  - sum
  - count
- ==having子句等都是了解为主啦，也就是说考试不考的！！！==
- ==嵌套子查询也不考！！！是不是很爽！==
- some，any有可能会考
- exists，not in也不会考
- 练习题：P107 3.9 , 3.11

## 第四章 中级SQL

- 学会视图的创建
- 视图的更新，物化，依赖都只需了解不会考
- ==授权需要掌握，经常会考选择题！！！==
  - 权限包括
    - 读取数据
    - 插入数据
    - 更新数据
    - 删除数据

  - 权限的授予和收回
    - 权限是可传递：A给B授权后，B也可以给C授权
    - 不级联收回restrict: A给B授权，B给C授权，当A对B收回时本应B对C的授权也失效，但加入关键字后一旦涉及级联收回就会返回错误，不执行收权
    - 级联回收cascade
    - 部分回收revoke：明确指出回收的权限，未指出的权限仍然保留


```sql
> GRANT <权限列表>
> ON <关系名或视图名>
> TO <用户或角色列表>; //授予


>REVOKE <权限列表>
>ON <关系名或视图名>
>FROM <用户或角色列表>;//收回
```



- 练习题： P152  4.1



## 第五章 高级SQL

- 本章只可能出选择题，嵌入式SQL，ODBC等都只需要了解不会考
- 什么是SQL通信区
  - 一个内存区域,每个数据库请求都会利用这个区域将统计信息和错误从应用程序传递到数据库服务器再回传到应用程序

- 什么是主变量
  - SQL 语句中使用的**主语言程序变量**
    - 输入主变量：由应用程序对其赋值， SQL 语句引用
    - 输出主变量：由 SQL 语句对其赋值或设置状态信息，返回给应用程序

- 什么是游标
  - 使用户可逐行访问由SQL Server返回的结果集。使用游标(cursor)的一个主要的原因就是把集合操作转换成单个记录处理方式。

- 什么是指示变量
  - 是一个整型变量，用来“指示”所指主变量的值或条件
  - 用途
    - 指示输入主变量是否为空值
    - 检测输出主变量是否为空值，值是否被截断

- 函数和过程的概念
  - 有考过让写一个函数或者写一个过程，但是基本不会考
- 什么是触发器
  - 是一条当对数据库作修改时，它自动被系统执行的语句
  - 必须满足的两个要求
    - 指明什么条件下执行触发器
    - 指明触发器执行时的动作

- ==怎么创建一个触发器 ！！！==

```sql
create table account(
	acct_num int,
    amount decimal(10, 2)
);

create trigger ins_sum
before insert
on account
for each row set @sum = @sum + new.amount
```

- 行触发器和语句触发器的区别
  - 行触发器是指一条SQL语句影响的每一行触发一次，即对每一行数据做处理
  - 语句级触发器是指一条SQL语句触发一次，语句执行完成后，对该语句的后续业务做处理
  - 过渡表不能用于before触发器，但可用于alter触发器



## 第六章 ER图

==一定会考一个大题！！！==

- 要会画ER图，一般是将其补充完整，也可能画一个新图

- 什么是属性

  - 刻画实体的某一个角度

- 什么是联系

  - 多个实体之间的关联关系

- 什么是实体

  - 现实世界中可区别于其他所有对象的一个“事物”或“对象”

- 属性的划分

  - 简单和复合属性
    - 简单属性：不能划分问更小的部分
    - 复合属性：可划分为更小的属性或其他属性，如name可划分为first name和 last name

  - 单值和多值属性
    - 单值属性：对一个特定实体都只有一个单独的值，如ID属性只对应一个学生的ID
    - 多值属性：对一个特定实体都只有一个单独的值，如电话号码属性，一个人可以有很多电话号

  - 派生属性：属性的值可以从别的相关属性或实体派生而来，如一个属性表示某教师指导了多少学生，可通过统计与该教师相关联的学生实体数目来确定属性的值

- 实体，强实体，弱实体怎么表示

  - 实体
    - 两部分的矩形表示：上部分为实体集名字，下部分为所有属性名字，主码用下划线表示

  - 弱实体集：没有足够多的属性以形成主码
    - 弱实体集所有属性都得加上虚下划线

  - 强实体集：有主码的实体集
    - 同实体的表示

- 联系一对一，一对多，多对一，多对多怎么判断

  - 一对一：联系集向两实体集各画一个箭头
  - 一对多：箭头指向一，线段指向多
  - 多对多：联系集向两实体集各画一条线段

- 联系怎么转化成表

  - 通常都是用菱形表示
  - 当两实体集是一弱一强时，用双菱形表示

- 属性怎么转化成关系模式

  - 强实体集

    - 如student实体集有三个属性id，name，cred 

      转化后为关系模式为student(<u>id</u> , name ,cred)，主码用下划线表示

  - 弱实体集

    - 加入所依赖实体集的主码并全部加入下划线

      如上述student实体集为弱实体集，依赖于teacher，且teacher的主码为tid

      则转化后的关系模式为student(<u>tid</u>, <u>id</u> , <u>name</u> , <u>cred</u>)

- 部分参与，完全参与，以及怎么画

  - 部分参与：虚线表示
  - 完全参与：双线表示


## 第七章 数据库概论

==一定会考大题！！！==

- 第一范式，第二范式，第三范式，BC范式是重点，第四范式了解即可

  - 主属性，非主属性

    - 若某关系模式有属性ABCD,若有AB->CD，则==（以下都以此关系为例）==
      - AB为该关系模式的候选码，A,B属性是主属性（构成候选码的属性）
      - C,D属性是非主属性

  - 第一范式：该域的元素都是不可再分的单元
    - 一个属性里可以有多个值；又或者是组合属性，是由多个属性组合而成的都不是第一范式
  - 第二范式：不存在非主属性对码的部分函数依赖，或者属性都是候选码的子集
    - 如：比如下面一个relation:  Takes(S_ID, name, class_id, grade, credit)。candidate key是{ S_ID, class_id }，因为只有这两个在一起才能确定一行。那么这两个属性就满足了二范式的第一条；接下来看其他的属性满不满足第二条。首先是name，它部分依赖于candidate key吗？是的！因为只要S_ID确定了，name就确定了。那很显然name就不满足第二个条件，那么整个的Relation也不满足二范式。
    - 如有：A->C，C是非属性，但由于AB是候选码，C对A产生了部分依赖，则该范式不是2NF
  - 第三范式：不存在非主属性对码的传递函数依赖
    - 对于F$^+$中所有形如A->B的函数依赖（A，B都属于关系R），有至少一条成立
      - A->B是一个平凡的函数依赖
      - A是R的一个超码
      - B-A中的每个属性都包含在R的一个候选码中
    - 如有：AB->C，C->D，则非主属性D对候选码AB具有传递依赖，则该范式不是3NF

    >
    >
    >==如果一个关系模式只有主属性没有非主属性，则其至少都是一个3NF==
  - BC范式：消除了所有基于函数依赖能够发现的冗余（主属性对候选码没有部分依赖和传递依赖）
    - 对于F$^+$中所有形如A->B的函数依赖（A，B都属于关系R），有至少一条成立
      - A->B是平凡的函数依赖，即$B\subseteq A$
      - A是模式R的一个超码
      
      >
      >
      >==总结起来也就是->左边一定是候选码==
    - 一个数据库设计属于BCNF的条件
      - 构成该设计的关系模式集中的每个模式都属于BCNF

- 函数依赖
  - 定义：
    - 对于R(U)的任意一个可能的关系r，**对于X的每一个具体值，Y都有唯一的具体值与之对应**，（但我们也可能不知道Y的值具体是多少，只是知道Y一定会被确定下来，如有了学生的ID,就一定能确定学生的名字，但具体的名字是张三还是李四我们就不知道了，但名字一定是个确值），则称Y函数依赖于X

  - 平凡函数依赖
    - 设FD X->Y,如果$Y \subseteq X$,则称X->Y为平凡的函数依赖

    - 如：有（ID,name），则我们能推出ID即是平凡的函数依赖

  - 非平凡函数依赖
    - 设FD X->Y,如果$Y \not\subseteq X$,则称X->Y为不平凡的函数依赖

  - 闭包：
    - 记为F$^+$,也就是能够从给定的F集合上推导出的所有函数依赖的集合，也就是说F$^+$包含了F的所有函数依赖

  - 完全函数依赖：
    - 定义：如果存在 X 属性组（注意是组，说明是联合主键）决定 唯一的 Y ，但 X 中的任一子集却不能决定唯一的 Y，则 Y 完全依赖于 X
    - 如：学生的成绩由学生与课程共同决定。所以成绩完全依赖于学生与课程
    
      ​		也就是说只知道学生的名字和只知道课程都不能退出该学生在某一课上的成绩
  - 部分函数依赖：
    - 定义：如果存在 X 属性组（注意是组，说明是联合主键）决定 唯一的 Y ，且 X 中的任一子集都能能决定唯一的 Y，则 Y 部分依赖于X
    - 如：在没有同名的情况下，学号与姓名都可以决定一个学生的年龄、性别等信息
  - 传递函数依赖：
    - 定义：设 R 为任一给定关系， X Y Z 为其不同的属性子集，若 X —> Y 且 Y —>Z，则有 X —>Z，称为 Z 传递函数依赖于 X
    - 如：学号可以唯一确定一个系部，且系部可以唯一确定一个系主任

- 无损连接
  - 分解后的关系能够通过自然连接可以恢复成原来的样子
  - 如何判断分解是无损连接，还是函数依赖保持
    - 无损分解
      - $R_1 \cap R_2 \rightarrow R_1 $ 
      - $R_1 \cap R_2 \rightarrow R_2 $ 
      - 满足以上两个式子，或者$R_1 \cap R_2  $是$R_1 或者R_2$的超码则成为无损分解

    - 函数依赖保持
      - 如果F上的每一个函数依赖都在其分解后的某一个关系上成立，则这个分解是保持依赖的 

- 闭包的三个公理，四个推论
  - 公理
    - 自反律：若A为一个属性集且$B \subseteq A$，则A->B成立
    
      ​				eg: AB->A，AB->B是一定成立的
    - 增补律：若A->B成立，且C是一个属性集，则CA->CB成立
    
      ​				即在左右两边同时增加属性，函数依赖仍然成立
    
    - 传递律：若A->B，B->C成立，则A->C成立
    
  - 四个推论：
    - 合并律：若A->B，A->C，则由A->BC，即左部相同，右部合并
    - 分解律：若A->BC，则有A->B，A->C成立，即和合并律相反
    - 伪传递律：若A->B，BC->D成立，则有AC->D成立
    
      ​				其实也就是AC->BC由于题设BC->D，则有AC->D
    - 集合累计：若A->BC，C->D，则有A->BCD
    
      ​				即BC->BD，由于题设A->BC，则有A->BD，由于自反律，A->C，综上有A->BCD


- 属性集的闭包有什么作用
  - 通过计算的方法能判断函数依赖是否成立
  - 可以高效检验超码
  - 推论
    - F=X->Y   <=>  $ (X->Y)\in F^+$  <=>  $Y \subseteq X_F^+$
- 函数集的闭包有什么作用
  - 所有函数依赖的闭包
- 作业需要重点看看！！！      P368  8.6 ，8.7



![image-20230213134807786](image\image-20230213134807786.png)

## 第十二章 索引和哈希

最多只会考一个选择题

- 什么是主索引
  - 又称聚集索引，指包含记录的文件按照某个搜索码指定的顺序排列，那么该搜索码对应的索引成为聚集索引

- 什么是辅助索引
  - 又称非聚集索引，指搜索码指定的顺序文件中记录的物理顺序不同的索引

- 什么是哈希索引
  - 将搜索码及其对应指针组织成散列文件结构

- 什么是稠密索引
  - 文件中的每个搜索码值都有一个索引项

- 什么是稀疏索引
  - 只为搜索码的某些值建立索引项

- R树和B树的区别
  - B树：每个节点都存储key和data，所有节点组成这棵树，并且叶子节点指针为null
  - $B^+$树：只有叶子节点存储data，叶子节点包含了这棵树的所有键值，叶子节点不存储指针。所有非终端节点看成是索引，节点中仅含有其子树根节点最大(或最小)的关键字，不包含查找的有效信息。B+树中所有叶子节点都是通过指针连接在一起。
    - 从根到叶的所有路径长度相同。
    - 每个不是根或叶的节点都有$\lceil \dfrac{n}{2} \rceil$ 到$n$个 孩子
    - 每个叶子结点$\lceil \dfrac{n-1}{2} \rceil$ 到 $n-1$ 值.
    - 根的规范
      - 至少有2个，至多有n个孩子
      - 如果树只有根节点，也就是说根节点也是一个叶子，那么他的值介于0到n-1之间
  - R树：
    - R树是B树在高维空间的扩展，是一棵平衡树。每个R树的叶子结点包含了多个指向不同数据的指针，这些数据可以是存放在硬盘中的，也可以是存在内存中。根据R树的这种数据结构，当我们需要进行一个高维空间查询时，我们只需要遍历少数几个叶子结点所包含的指针，查看这些指针指向的数据是否满足要求即可。
      ![image-20230216153832700](image\image-20230216153832700.png)
  - 会更新即可
  
- ==什么时候用索引是必须掌握的！！==
  - 经常要用于查询的列
  - 经常要用于排序，分组的列
  - 有值唯一性限制的列，比如主键，身份证号等

## 第十三章 查询和优化

以概念为主，不会出大题

- 查询的基本概念
  - 将信息从数据库中检索而出

- 优化的基本概念
  - 从许多的查询策略中找出最有效的查询执行计划的一种处理过程

- 等价规则的理解（只需最简单的即可）
  - 两种不同形式的表达式是等价的可以相互替换
  - 满足交换律
    - 选择
    - $\theta $连接
    - 并交运算

  - 满足结合律
    - 自然连接
    - $\theta $连接
    - 并交运算

  - 例如：以下四个式子哪个不满足等价规则

- 给一个式子将其简化
  - 能投影先投影，能选择就选择，尽量不连接



## 第十五章 事务

==一定会考！！！==

- ==事务的定义和四大特性！！！==
  - 原子性：要么全都做，要么全不做
    - 如转账时要么一边扣款，一边收款，不能说一边扣款成功，但是另一边却没有收款
  - 隔离性：尽管多个事务可能并发执行，但每个事务都察觉不到还有其他事务在并发执行
    - 也就相当于是高并发，而非真正的并行
  - 一致性：在串行执行的时候，每一个结果都要是正确的
  - 持久性：事务提交之后，对系统的影响是永久的
    - 不能说显示转账成功之后，第二天发现钱又回来了，也就是说相当于转账操作失败了
  
- 事务的五个状态

  - 活动状态：初始状态，事务执行时的状态
  - 部分提交状态：最后一条语句执行后
  - 失败状态：发现正常的执行不能继续后
  - 中止状态：事务回滚并且数据库已恢复到事务开始执行前的状态后
  - 提交状态：成功完成后

- 事务状态的转化，一个状态可以到什么状态，不能到什么状态

  ![image-20230218162501537](image\image-20230218162501537.png)

- 并发的概念

  - 即事务可共享数据库资源，多个事务能同时对数据库中的同一数据进行操作

- ==什么是可串行调度！！！==

  - 当多个事务的一次并发执行效果与他们的某一种串行执行效果一样时，称这种并发调度策略为可串行化调度
  - 冲突可串行化
    - 冲突：当I，J是不同事务在相同数据上的操作，并且其中至少有一个是write指令时，我们就说I，J是冲突的
    - 冲突等价：如果调度S可以经过一系列非冲突指令交换转换成$S’$，则称S和$S’$冲突等价
    - 冲突可串行化：若一个调度S与一个串行调度冲突等价，则称调度S为冲突可串行化
      - 为确定一个调度是否冲突可串行化

- 脏读、幻读、不可重复读

  - 脏读：事务读取到另一事物还未提交的数据
  - 幻读：例如两个事务同时对数据库进行操作，T1事务将表中所有数据置为1，T2事务又同时向数据库插入一条值为0的数据，当值T1事务的用户发现还有未修改的数据行，像发生了幻觉一样
  - 不可重复读：事务T1需要多次反复读取同一个数据，事务T2将该数据进行修改，当T1再次读取时发现数据不匹配了

- 四个隔离级别

  - 什么时候是可串行化的
    - 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**。
  - 什么时候是可重读的
    -  对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生**。
  - 什么时候是提交读的
    - 允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻读或不可重复读仍有可能发生**。
  - 什么时候是未提交读的
    - 最低的隔离级别，允许读取尚未提交的数据变更，**可能会导致脏读、幻读或不可重复读**。
    - ![image-20230218170530933](image\image-20230218170530933.png)

## 并发

==经常考大题！！！==

- 排它锁，共享锁

  - 排它锁（X）：本事务可进行读写，其他事务不能进行任何操作

  - 共享锁（S）：该事物只能读不能写
  
    - 相容性
  
      |      |   S   |   X   |
      | :--: | :---: | :---: |
      |  S   | true  | false |
      |  X   | false | false |
  
      
  
  - 两相锁协议
  
    - 增长阶段（操作之前）：允许申请锁，不允许释放锁
  
    - 消减阶段（操作之后）：允许释放锁，不允许申请锁
  
      >
      >
      >满足则一定能可串行化调度，但由于并不必须一次性将所有所需的资源上锁，所以仍有可能死锁
  
  - 有可能还是会死锁
  
- ==用两相锁协议对代码进行改造，使其能满足可串行化！！！==

- 死锁的概念

  - 两个或多个事务,各自占有对方的期望获得的资源,形成的循环等待,彼此无法继续正常执行的一种状态

- 知道怎么处理死锁

  - 死锁预防
    - 对加锁请求进行排序或者同时获得所有的锁来保证不会循环等待
    - 每当等待可能导致死锁，就进行事务回滚而不是等待加锁

  - 死锁恢复
    - 选择牺牲者：回滚某一事务来打破死锁
    - 回滚
      - 彻底回滚：终止该事物，然后重新开始
      - 部分回滚：只回滚到可以解除死锁的地方

    - 饿死：有可能同一事务总被选为牺牲者，导致事务一直不能完成，所以必须保证被选为牺牲者的次数有限

- 时间戳协议
  - 也可能要求不用两相锁协议，而是用时间戳协议将代码进行改造
  - 时间戳：将系统中的每一个事务T，我们都把一个唯一的固定时间戳和他联系起来

    - 使用系统时间：事务的时间戳等于该事务进入系统时的时钟值
    - 使用逻辑计数器：没赋予一个时间戳，计数器增加计数，即事务的时间戳等于该事务进入系统时的计数器值

    > 事务的时间戳决定了串行化的顺序，先后进入i ，j事务则TS(Ti)<TS(Tj)，则事务i一定出现在事务j之前的某个串行调度
  - 时间戳协议：保证任何有冲突的read和write操作按时间戳顺序执行
  - 不会死锁

## 恢复

==不会出大题==

- 相关概念
  - 旧值：数据项写前值
  - 新值：数据项写后值
  - $<T_i \ start> ，事务T_i开始$
  - $<T_i\ commit>, 事务T_i提交$
  - $<T_i \ abort>, 事务T_i中止$
- 什么时候undo
  - undo：这一阶段回滚在发生崩溃时那些不完全的事务，事务更新过的所有数据项的值都恢复成旧值
  - 从尾部开始搜索直至遇到第一条<checkpoint L>，若日志中既没有<T commit>记录，也没有<T abort>记录，则undo(T)
- 什么时候redo
  - 从分析阶段决定的位置开始，执行重做，重复历史，将数据库恢复到发生崩溃前的状态，事务更新过的所有数据都恢复为新值
  - 从尾部开始搜索直至遇到第一条<checkpoint L>，若日志中有<T commit>记录，或有<T abort>记录，则redo(T)
  - 给代码然后判断
- 什么是WAL
  -  Write Ahead Log(预写日志)，数据文件(存储着表和索引)的修改必须在这些动作被日志记录之后才被写入。利用WAL日志进行恢复的方法能最大程度上恢复数据库系统未落盘数据,能明显提高数据库可用性和容错容灾能力。




## NoSQL

- 知道什么时候用NoSQL，什么时候用SQL

  - NoSQL
    - 针对大数据或者海量数据进行存储
    - 数据之间的关联特别复杂
    - 具有非结构化的特点
    - 分布式的需求

- CAP理论

  - CAP概念

    - C: Consistency一致性,更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致
    - A: Availability可用性,服务一直可用，而且是正常响应时间
    - P: Partition tolerance分区容错性,分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务

  - 什么时候用CA、AP、CP

    - 分布式系统一定会满足P，所以CA只是存在于理论上的

    - AP:写请求把用户姓名【张三】改为【李四】，写请求写入主Mysql成功后，系统就直接返回成功；然后再通过主Mysql的binlog日志方式把数据同步到从Mysql,因为如果出现网络延迟，数据没有及时同步到从Mysql，那就导致了主Mysql值为李四，而从Mysql值为张三，导致数据不一致。但主从mysql照样可以提供服务，也就是保证了可用性A。

      ![image-20230219154643577](image\image-20230219154643577.png)

    - CP:写请求把用户姓名【张三】改为【李四】，写请求一定要等到主从mysql都写入成功了，系统才能成功返回。网络出现问题时，主mysql无法访问从节点，导致写操作一直不成功。其实就是放弃了可用性

- NoSQL和关系型数据库的区别

  - 通过哈希函数来讲变长的输入转化成固定长度的输出来进行存储，可在数据库中存放不规则的或者非结构化的数据
  - 最终以键值对的形式来进行存储
  - 不需要固定的存储模式

- ACID和BASE的区别

  - ACID 更强调数据一致性，这是传统数据库设计的思路。而BASE 更强调可用性， 弱化数据强一致性的概念
  - BASE模型反ACID模型，完全不同ACID模型，牺牲高一致性，获得可用性或可靠性

- RDBMS和NoSQL的区别

  - RDBMS
    - 结构化组织 
    - SQL 
    - 数据和关系都存在单独的表中 
    - 数据定义语言 
    - 严格的一致性 
    - 基础的事务
  - NoSQL
    - 不仅仅是数据 
    - 没有固定的查询语言 
    - 键值对存储，列存储我，文档存储，图形数据库 
    - 最终一致性 
    - CAP定理和BASE 
    - 保证高性能，高可用，高可扩展
